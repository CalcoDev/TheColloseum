#include <glad/glad.h>
// seaprate so that glad is always first
#include <glfw/glfw3.h>
#include <stdio.h>

#define STB_IMAGE_IMPLEMENTATION
#include "stb/stb_image.h"

#include "base/base_include.h"
#include "os/os.h"
#include "render/render.h"

void glfwErrorCallback(int code, const char* msg)
{
  LogError("glfw error: %s (%i)", msg, code);
}

// Mouse and movement
void ProcessWindowInput(
    GLFWwindow* window, int key, int scancode, int action, int mods
)
{
  if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
  {
    glfwSetWindowShouldClose(window, GLFW_TRUE);
  }
}

static F32 MoveSp      = 0.05f;
static F32 Sensitivity = 0.01f;
static F32 Yaw         = -90.f;
static F32 Pitch       = 0.f;

static Vec2F32 MousePos = {0};
static F32 _lastX       = 0.f;
static F32 _lastY       = 0.f;

void CursorPositionCallback(GLFWwindow* window, F64 d_xpos, F64 d_ypos)
{
  F32 xpos = (F32)d_xpos;
  F32 ypos = (F32)d_ypos;

  F32 xoff = (xpos - _lastX) * Sensitivity;
  F32 yoff = (_lastY - ypos) *
             Sensitivity; // inverted because window coords are inverted

  _lastX = xpos;
  _lastY = ypos;

  Yaw += xoff;
  Pitch += yoff;

  if (Pitch > 85.f)
    Pitch = 85.f;
  else if (Pitch < -85.f)
    Pitch = -85.f;
}

int _main()
{
  OS_Init();

  M_BaseMemory memory = OS_BaseMemory();
  Arena arena;
  ArenaInit(&arena, &memory, Megabytes(1));

  ArenaRelease(&arena);
  return 0;
}

int main()
{
  // NOTES(calco): Init Memory
  OS_Init();

  M_BaseMemory memory = OS_BaseMemory();
  Arena arena;
  ArenaInit(&arena, &memory, Gigabytes(1));

  // NOTES(calco): GLFW
  Log("Initialising glfw.", "");
  if (!glfwInit())
  {
    LogFatal("Error initializing GLFW!", "");
  }
  glfwSetErrorCallback(glfwErrorCallback);

  // Init opengl in window.
  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
  glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
  glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE); // Mac

  GLFWmonitor* monitor    = glfwGetPrimaryMonitor();
  GLFWvidmode* video_mode = glfwGetVideoMode(monitor);
  U32 window_width        = video_mode->width / 2;
  U32 window_height       = video_mode->height / 2;

  Log("Creating glfw window.", "");
  GLFWwindow* window =
      glfwCreateWindow(window_width, window_height, "Direct X-ing", NULL, NULL);
  if (window == NULL)
  {
    glfwTerminate();
    LogFatal("Error occured creating glfw window.", "");
  }

  // Center the window
  U32 window_left = video_mode->width / 2 - window_width / 2;
  U32 window_top  = video_mode->height / 2 - window_height / 2;
  glfwSetWindowPos(window, window_left, window_top);

  // Lock the mouse to the screen
  glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

  // Set up key callbacks.
  glfwSetKeyCallback(window, ProcessWindowInput);
  glfwSetCursorPosCallback(window, CursorPositionCallback);

  // Set window to current context
  glfwMakeContextCurrent(window);

  // Init glad
  if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
  {
    LogFatal("Error initialising glad.", "");
    glfwTerminate();
    return -1;
  }

  // Data
  F32 vertices[] = {
      -1.f,  -1.f,  0.5f,  // 0
      1.0f,  1.0f,         // tex coords
      1.f,   -1.f,  0.5f,  // 1
      1.0f,  -1.0f,        // tex coords
      -1.f,  1.f,   0.5f,  // 2
      -1.0f, -1.0f,        // tex coords
      1.f,   1.f,   0.5f,  // 3
      -1.0f, 1.0f,         // tex coords
      -1.f,  -1.f,  -0.5f, // 4
      -1.0f, 1.0f,         // tex coords
      1.f,   -1.f,  -0.5f, // 5
      -1.0f, 1.0f,         // tex coords
      -1.f,  1.f,   -0.5f, // 6
      -1.0f, 1.0f,         // tex coords
      1.f,   1.f,   -0.5f, // 7
      -1.0f, 1.0f,         // tex coords
  };
  U32 indices[] = {
      2, 6, 7, // Top
      2, 3, 7, // Top
      0, 4, 5, // Bottom
      0, 1, 5, // Bottom
      0, 2, 6, // Left
      0, 4, 6, // Left
      1, 3, 7, // Right
      1, 5, 7, // Right
      0, 2, 3, // Front
      0, 1, 3, // Front
      4, 6, 7, // Back
      4, 5, 7  // Back
  };

  // Create a vertex buffer
  R_Buffer vertex_buffer = {0};
  R_BufferInit(&vertex_buffer, BufferFlag_Type_Vertex);
  R_BufferData(&vertex_buffer, vertices, sizeof(vertices));

  // Create an index buffer
  R_Buffer index_buffer = {0};
  R_BufferInit(&index_buffer, BufferFlag_Type_Index);
  R_BufferData(&index_buffer, indices, sizeof(indices));

  // Do some shaders real quick.
  String8 exe_path = OS_PathExecutableDir(&arena);

  String8 vs_path = OS_PathRelative(
      &arena, exe_path, Str8Lit("./assets/shaders/default_vert.vs")
  );
  String8 vs_data = OS_FileRead(&arena, vs_path);
  R_Shader vs;
  R_ShaderInit(&vs, ShaderType_Vertex);
  R_ShaderData(&vs, vs_data);

  String8 fs_path = OS_PathRelative(
      &arena, exe_path, Str8Lit("./assets/shaders/default_frag.fs")
  );
  String8 fs_data = OS_FileRead(&arena, fs_path);
  R_Shader fs;
  R_ShaderInit(&fs, ShaderType_Fragment);
  R_ShaderData(&fs, fs_data);

  R_Shader* shaders[2] = {&vs, &fs};
  R_ShaderPack program;
  R_ShaderPackInit(&program, shaders, 2, &arena, 7);

  // Create the actual rendering pipeline.
  R_Attribute vertex_attribs[2];
  vertex_attribs[0].name = Str8Lit("Position");
  vertex_attribs[0].type = AttributeType_F3;
  vertex_attribs[1].name = Str8Lit("TexCoord");
  vertex_attribs[1].type = AttributeType_F2;

  R_Pipeline pipeline;
  R_PipelineInit(&pipeline, &program, vertex_attribs, 2);
  R_PipelineAddBuffer(&pipeline, &vertex_buffer);
  R_PipelineAddBuffer(&pipeline, &index_buffer);

  // Some texture action lol
  String8 texture_path =
      OS_PathRelative(&arena, exe_path, Str8Lit("./assets/sprites/player.jpg"));

  S32 x, y, channels;
  stbi_set_flip_vertically_on_load(1);
  char* data = stbi_load((const char*)texture_path.data, &x, &y, &channels, 0);

  R_Texture texture;
  R_TextureInit(
      &texture, x, y, TextureWrap_ClampToEdge, TextureWrap_ClampToEdge,
      TextureFilter_Nearest, TextureFilter_Nearest, TextureFormat_RGB, NULL
  );

  R_TextureData(&texture, (void*)data);

  stbi_image_free(data);

  PrecisionTime elapsed_time      = 0;
  PrecisionTime prev_loop_time    = 0;
  PrecisionTime current_loop_time = 0;
  PrecisionTime delta_time        = 0;

  // Model Matrix (local to world)
  Mat4x4F32 model_matrix = Mat4x4_MakeValue(0.f);

  Vec3F32 translate     = Vec3F32_Make(0.f, 0.f, 0.f);
  Vec3F32 rotation_axis = Vec3F32_Up;
  F32 rotation_radians  = 0.f; // F32_Pi * 0.25f
  Vec3F32 scale         = Vec3F32_One;

  // Projection Matrix
  Mat4x4F32 projection_matrix = Mat4x4_MakeValue(0.f);

  F32 half_fov     = F32_DegToRad(45.f);
  F32 aspect_ratio = (F32)window_width / (F32)window_height;
  F32 c_near       = 0.1f;
  F32 c_far        = 100.f;

  projection_matrix.elements[0][0] = 1.f / (F32_Tan(half_fov) * aspect_ratio);
  projection_matrix.elements[1][1] = 1.f / F32_Tan(half_fov);
  projection_matrix.elements[2][2] = -(c_far + c_near) / (c_far - c_near);
  projection_matrix.elements[3][2] = -1.f;
  projection_matrix.elements[2][3] = -(2.f * c_far * c_near) / (c_far - c_near);

  // View Matrix / Camera
  Mat4x4F32 view_matrix = Mat4x4_MakeValue(0.f);

  Vec3F32 camera_pos = Vec3F32_Make(0.f, 0.f, 10.f);
  Vec3F32 camera_forward =
      Vec3F32_Normalize(Vec3F32_Sub(camera_pos, Vec3F32_Zero));
  Vec3F32 camera_right =
      Vec3F32_Normalize(Vec3F32_Cross(Vec3F32_Up, camera_forward));
  Vec3F32 camera_up =
      Vec3F32_Normalize(Vec3F32_Cross(camera_forward, camera_right));

  Log("Starting game loop.", "");
  while (!glfwWindowShouldClose(window))
  {
    current_loop_time = OS_TimeMicroseconds();
    delta_time        = current_loop_time - prev_loop_time;
    elapsed_time      = elapsed_time + delta_time;

    // 60 FPS, both render and update
    if (delta_time > 16000)
    {
      glfwPollEvents();

      // -- start of camera
      // Camera Position
      Vec3F32 inp;
      inp.x = (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) -
              (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS);
      inp.z = (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) -
              (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS);
      inp.y = (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS) -
              (glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS);
      // inp = Vec3F32_Normalize(inp);

      // Vec3F32 x_axis = Vec3F32_MultScalar(
      //     Vec3F32_Cross(camera_forward, camera_up), inp.x * MoveSp
      // );
      // Vec3F32 y_axis   = Vec3F32_MultScalar(camera_up, inp.y * MoveSp);
      // Vec3F32 z_axis   = Vec3F32_MultScalar(camera_forward, inp.z * MoveSp);
      // Vec3F32 movement = Vec3F32_Add(Vec3F32_Add(x_axis, y_axis), z_axis);
      // camera_pos       = Vec3F32_Add(camera_pos, movement);

      // Camera Rotation
      // Log("Yaw (%.2f) - Pitch (%.2f)", Yaw, Pitch);
      // F32 b = (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS) -
      //         (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS);
      // if (F32_Abs(b) > 0.01f)
      // {
      //   const F32 angle = F32_DegToRad(1.f) * b;

      //   Vec3F32 axis = Vec3F32_Cross(Vec3F32_Up, camera_forward);
      //   axis         = Vec3F32_Normalize(axis);

      //   camera_forward = Vec3F32_RotateAxis(camera_forward, axis, angle);
      //   camera_forward = Vec3F32_Normalize(camera_forward);

      //   camera_up = Vec3F32_Cross(camera_forward, axis);
      //   camera_up = Vec3F32_Normalize(camera_up);
      // }

      // b = (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS) -
      //     (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS);
      // if (F32_Abs(b) > 0.01f)
      // {
      //   const F32 angle = F32_DegToRad(1.f) * b;

      //   Vec3F32 axis = Vec3F32_Cross(Vec3F32_Up, camera_forward);
      //   axis         = Vec3F32_Normalize(axis);

      //   camera_forward = Vec3F32_RotateAxis(camera_forward, Vec3F32_Up,
      //   angle); camera_forward = Vec3F32_Normalize(camera_forward);

      //   camera_up = Vec3F32_Cross(camera_forward, axis);
      //   camera_up = Vec3F32_Normalize(camera_up);
      // }

      // -- end of camera

      // Rotate the cube.
      // rotation_radians += delta_time / 1000.f / 500.f;
      // if (F32_Abs(rotation_radians) > 2 * F32_Pi)
      //   rotation_radians = 0.f;

      // Model Matrix
      model_matrix = Mat4x4_Mult(
          Mat4x4_MakeTranslate(translate),
          Mat4x4_Mult(
              Mat4x4_MakeRotation(rotation_axis, rotation_radians),
              Mat4x4_MakeScale(scale)
          )
      );

      // View Matrix
      Vec3F32 n = camera_forward;
      Vec3F32 v = camera_up;
      Vec3F32 u = Vec3F32_Cross(n, v);

      view_matrix = Mat4x4_MakeValue(0.f);

      view_matrix.elements[0][0] = u.x;
      view_matrix.elements[0][1] = u.y;
      view_matrix.elements[0][2] = u.z;
      view_matrix.elements[1][0] = v.x;
      view_matrix.elements[1][1] = v.y;
      view_matrix.elements[1][2] = v.z;
      view_matrix.elements[2][0] = n.x;
      view_matrix.elements[2][1] = n.y;
      view_matrix.elements[2][2] = n.z;
      view_matrix.elements[0][3] = -camera_pos.x;
      view_matrix.elements[1][3] = -camera_pos.y;
      view_matrix.elements[2][3] = -camera_pos.z;

      // MATRIX STUFF OVER

      // Render
      glEnable(GL_DEPTH_TEST);
      glDepthMask(GL_TRUE);
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
      glClearColor(0.2f, 0.3f, 0.3f, 1.0f);

      R_TextureBind(&texture, 0);
      R_PipelineBind(&pipeline);

      R_ShaderPackUploadMat4(
          pipeline.shader_pack, Str8Lit("model"), model_matrix.elements[0]
      );
      R_ShaderPackUploadMat4(
          pipeline.shader_pack, Str8Lit("view"), view_matrix.elements[0]
      );
      R_ShaderPackUploadMat4(
          pipeline.shader_pack, Str8Lit("projection"),
          projection_matrix.elements[0]
      );

      glDrawElements(
          GL_TRIANGLES, sizeof(indices) / sizeof(U32), GL_UNSIGNED_INT, (void*)0
      );

      glfwSwapBuffers(window);

      prev_loop_time = current_loop_time;
    }
  }

  // Clean up after OpenGL
  R_BufferFreeGPU(&vertex_buffer);
  R_BufferFreeGPU(&index_buffer);

  R_ShaderFreeGPU(&vs);
  R_ShaderFreeGPU(&fs);
  R_ShaderPackFree(&program);

  R_PipelineFreeGPU(&pipeline);

  Log("Destroying window.", "");
  glfwDestroyWindow(window);
  Log("Terminating glfw.", "");
  glfwTerminate();
  ArenaRelease(&arena);
  return 0;
}